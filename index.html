<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sound Object Analyzer v8.0 - Final Fixed Version</title>
    <meta name="version" content="8.0.0">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: ui-sans-serif, system-ui, sans-serif;
            background-color: #f3f4f6;
        }
        
        .canvas-container {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }
        
        .canvas-container:hover {
            transform: scale(1.02);
            transition: transform 0.2s;
        }
        
        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5rem;
        }
    </style>
</head>
<body>
    <div class="max-w-7xl mx-auto p-6">
        <!-- Header -->
        <div class="bg-gradient-to-r from-blue-600 to-purple-700 text-white p-6 rounded-xl shadow-xl mb-6">
            <h1 class="text-4xl font-bold mb-2">Sound Object Analyzer v8.0</h1>
            <p class="text-blue-100 text-lg">Final Version - Proper Blue Extraction & Reference Circle</p>
            <div class="mt-4 flex flex-wrap gap-2">
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">âœ“ Fixed Blue Shape Detection</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">âœ“ Reference Head Circle</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">âœ“ Proper Contours</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">âœ“ Accurate Translation</span>
            </div>
        </div>
        
        <!-- Instructions -->
        <div class="bg-blue-50 p-6 rounded-xl mb-6 border-2 border-blue-200">
            <h2 class="text-xl font-bold text-blue-900 mb-3">How to Use</h2>
            <ol class="list-decimal list-inside space-y-2 text-gray-700">
                <li><strong>Upload Images:</strong> Select PNG files or ZIP archives from the drawing tool</li>
                <li><strong>Process:</strong> Click "Analyze & Generate Visualizations"</li>
                <li><strong>View Results:</strong> Composites with head reference circle, gray individual shapes, red/blue averages</li>
                <li><strong>Download:</strong> Click any image to save as PNG</li>
            </ol>
        </div>
        
        <!-- File Upload -->
        <div class="bg-white p-6 rounded-xl shadow-lg mb-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Upload Participant Images</h2>
            <input 
                type="file" 
                id="image-upload" 
                accept="image/png,.zip,application/zip" 
                multiple
                class="block w-full text-sm text-gray-700 mb-4
                    file:mr-4 file:py-3 file:px-6
                    file:rounded-xl file:border-0
                    file:text-sm file:font-bold
                    file:bg-gradient-to-r file:from-blue-500 file:to-blue-600
                    file:text-white
                    hover:file:from-blue-600 hover:file:to-blue-700
                    cursor-pointer"
            />
            
            <div id="file-status" class="text-sm text-gray-600 mb-4"></div>
            
            <button 
                id="analyze-btn" 
                class="bg-gradient-to-r from-green-500 to-emerald-600 text-white font-bold py-3 px-6 rounded-xl hover:from-green-600 hover:to-emerald-700 transition-all shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
                disabled>
                ðŸ”¬ Analyze & Generate Visualizations
            </button>
        </div>
        
        <!-- Progress -->
        <div id="progress-container" class="hidden bg-white p-6 rounded-xl shadow-lg mb-6">
            <div class="flex justify-between text-sm text-gray-600 mb-2">
                <span id="progress-text">Processing...</span>
                <span id="progress-percentage">0%</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-3 overflow-hidden">
                <div id="progress-bar" class="bg-gradient-to-r from-blue-500 to-green-500 h-full rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
        </div>
        
        <!-- Results -->
        <div id="visualization-container" class="hidden">
            <h2 class="text-2xl font-bold text-gray-800 mb-6">Composite Visualizations</h2>
            <div id="viz-grid" class="analysis-grid"></div>
        </div>
    </div>
    
    <script>
        // ============================================
        // CONFIGURATION - EXACT FROM DRAWING APP
        // ============================================
        
        const CANVAS_SIZE = 1000;
        const GRID_RANGE = 10; // -10 to +10 units
        const CENTER_X = 500;
        const CENTER_Y = 500;
        const SCALE = 50; // pixels per unit (500px / 10 units = 50)
        const HEAD_CIRCLE_RADIUS = 3; // units
        
        // Conversion functions matching original drawing tool
        const pixelsToUnits = (pixels) => pixels / SCALE;
        const unitsToPixels = (units) => units * SCALE;
        
        const canvasToUnit = (canvasX, canvasY) => ({
            x: (canvasX - CENTER_X) / SCALE,
            y: (CENTER_Y - canvasY) / SCALE  // Y inverted for proper coordinate system
        });
        
        const unitToCanvas = (unitX, unitY) => ({
            x: CENTER_X + unitX * SCALE,
            y: CENTER_Y - unitY * SCALE  // Y inverted
        });
        
        // ============================================
        // INITIALIZATION
        // ============================================
        
        document.addEventListener('DOMContentLoaded', () => {
            const uploadInput = document.getElementById('image-upload');
            const analyzeBtn = document.getElementById('analyze-btn');
            
            uploadInput.addEventListener('change', handleFileUpload);
            analyzeBtn.addEventListener('click', startAnalysis);
        });
        
        function handleFileUpload(event) {
            const files = Array.from(event.target.files);
            if (files.length === 0) return;
            
            const statusDiv = document.getElementById('file-status');
            const analyzeBtn = document.getElementById('analyze-btn');
            
            const zipCount = files.filter(f => f.name.toLowerCase().endsWith('.zip')).length;
            const pngCount = files.filter(f => f.name.toLowerCase().endsWith('.png')).length;
            
            statusDiv.innerHTML = `âœ… ${files.length} file(s) uploaded (${zipCount} ZIP, ${pngCount} PNG)`;
            
            analyzeBtn.disabled = false;
            analyzeBtn.classList.remove('disabled:opacity-50', 'disabled:cursor-not-allowed');
        }
        
        async function startAnalysis() {
            const uploadInput = document.getElementById('image-upload');
            const files = Array.from(uploadInput.files);
            
            if (files.length === 0) {
                alert('Please upload files first');
                return;
            }
            
            try {
                await analyzeData(files);
            } catch (error) {
                console.error('Analysis error:', error);
                alert(`Analysis failed: ${error.message}`);
            }
        }
        
        // ============================================
        // FIXED: PROPER SHAPE EXTRACTION
        // ============================================
        
        async function extractShapesFromImage(imageData, filename) {
            const width = imageData.width;
            const height = imageData.height;
            const data = imageData.data;
            
            // Collect colored pixels - FIXED color detection
            const redPixels = [];
            const bluePixels = [];
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    const a = data[idx + 3];
                    
                    // Skip transparent pixels
                    if (a < 128) continue;
                    
                    // Skip white pixels
                    if (r > 240 && g > 240 && b > 240) continue;
                    
                    // Skip gray pixels (grid lines and reference circle)
                    if (Math.abs(r - g) < 30 && Math.abs(g - b) < 30) {
                        // Check if it's actually a black reference circle (darker gray/black)
                        if (r < 100 && g < 100 && b < 100) continue;
                        // Check if it's a grid line (lighter gray)
                        if (r > 140 && r < 200) continue;
                    }
                    
                    // FIXED: Better color detection
                    // Blue pixels: blue channel dominant
                    if (b > r + 20 && b > g + 20) {
                        bluePixels.push({ x, y });
                    }
                    // Red pixels: red channel dominant  
                    else if (r > b + 20 && r > g + 20) {
                        redPixels.push({ x, y });
                    }
                }
            }
            
            console.log(`${filename}: Found ${redPixels.length} red pixels, ${bluePixels.length} blue pixels`);
            
            const shapes = [];
            
            // Process red shape
            if (redPixels.length > 100) { // Minimum threshold
                const redContour = traceContour(redPixels);
                if (redContour.length > 0) {
                    const redCentroid = calculateCentroid(redContour);
                    shapes.push({
                        phase: 'red',
                        contour: redContour,
                        centroid: redCentroid,
                        area: calculateContourArea(redContour)
                    });
                }
            }
            
            // Process blue shape
            if (bluePixels.length > 100) { // Minimum threshold
                const blueContour = traceContour(bluePixels);
                if (blueContour.length > 0) {
                    const blueCentroid = calculateCentroid(blueContour);
                    shapes.push({
                        phase: 'blue',
                        contour: blueContour,
                        centroid: blueCentroid,
                        area: calculateContourArea(blueContour)
                    });
                }
            }
            
            return shapes;
        }
        
        function traceContour(pixels) {
            if (pixels.length === 0) return [];
            
            // Find boundary pixels
            const pixelSet = new Set(pixels.map(p => `${p.x},${p.y}`));
            const boundaryPixels = [];
            
            pixels.forEach(pixel => {
                // Check if this is a boundary pixel
                let isBoundary = false;
                
                // Check 8 neighbors
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (dx === 0 && dy === 0) continue;
                        
                        const neighbor = `${pixel.x + dx},${pixel.y + dy}`;
                        if (!pixelSet.has(neighbor)) {
                            isBoundary = true;
                            break;
                        }
                    }
                    if (isBoundary) break;
                }
                
                if (isBoundary) {
                    boundaryPixels.push(pixel);
                }
            });
            
            if (boundaryPixels.length === 0) return [];
            
            // Order boundary points to form a contour
            const ordered = [];
            const remaining = new Set(boundaryPixels);
            
            // Start with leftmost point
            let current = boundaryPixels.reduce((min, p) => p.x < min.x ? p : min);
            ordered.push(current);
            remaining.delete(current);
            
            // Trace contour by finding nearest neighbors
            while (remaining.size > 0) {
                let nearest = null;
                let minDist = Infinity;
                
                remaining.forEach(point => {
                    const dist = Math.sqrt(
                        Math.pow(point.x - current.x, 2) + 
                        Math.pow(point.y - current.y, 2)
                    );
                    
                    if (dist < minDist && dist < 20) { // Max gap of 20 pixels
                        minDist = dist;
                        nearest = point;
                    }
                });
                
                if (nearest) {
                    ordered.push(nearest);
                    remaining.delete(nearest);
                    current = nearest;
                } else {
                    break; // Gap too large
                }
            }
            
            return ordered;
        }
        
        function calculateCentroid(contour) {
            if (contour.length === 0) return { x: CENTER_X, y: CENTER_Y };
            
            const sumX = contour.reduce((sum, p) => sum + p.x, 0);
            const sumY = contour.reduce((sum, p) => sum + p.y, 0);
            
            return {
                x: sumX / contour.length,
                y: sumY / contour.length
            };
        }
        
        function calculateContourArea(contour) {
            if (contour.length < 3) return 0;
            
            // Shoelace formula
            let area = 0;
            for (let i = 0; i < contour.length; i++) {
                const j = (i + 1) % contour.length;
                area += contour[i].x * contour[j].y;
                area -= contour[j].x * contour[i].y;
            }
            
            return Math.abs(area / 2) / (SCALE * SCALE); // Convert to square units
        }
        
        // ============================================
        // AVERAGING FUNCTIONS
        // ============================================
        
        function calculateAverageShape(shapes) {
            if (shapes.length === 0) return null;
            
            // Calculate average centroid
            const avgCentroid = {
                x: shapes.reduce((sum, s) => sum + s.centroid.x, 0) / shapes.length,
                y: shapes.reduce((sum, s) => sum + s.centroid.y, 0) / shapes.length
            };
            
            // Normalize contours relative to average centroid and convert to polar
            const polarData = [];
            
            shapes.forEach(shape => {
                shape.contour.forEach(point => {
                    const dx = point.x - avgCentroid.x;
                    const dy = point.y - avgCentroid.y;
                    const angle = Math.atan2(dy, dx);
                    const radius = Math.sqrt(dx * dx + dy * dy);
                    polarData.push({ angle, radius });
                });
            });
            
            // Bin by angle and average
            const numBins = 360;
            const bins = new Array(numBins).fill(null).map(() => []);
            
            polarData.forEach(point => {
                let binIndex = Math.floor(((point.angle + Math.PI) / (2 * Math.PI)) * numBins);
                binIndex = (binIndex + numBins) % numBins;
                bins[binIndex].push(point.radius);
            });
            
            // Create smooth averaged contour
            const avgContour = [];
            for (let i = 0; i < numBins; i++) {
                const angle = (i / numBins) * 2 * Math.PI - Math.PI;
                
                let radius;
                if (bins[i].length > 0) {
                    radius = bins[i].reduce((sum, r) => sum + r, 0) / bins[i].length;
                } else {
                    // Interpolate from neighbors
                    let prevIdx = (i - 1 + numBins) % numBins;
                    let nextIdx = (i + 1) % numBins;
                    
                    while (bins[prevIdx].length === 0 && prevIdx !== i) {
                        prevIdx = (prevIdx - 1 + numBins) % numBins;
                    }
                    while (bins[nextIdx].length === 0 && nextIdx !== i) {
                        nextIdx = (nextIdx + 1) % numBins;
                    }
                    
                    if (bins[prevIdx].length > 0 && bins[nextIdx].length > 0) {
                        const prevRadius = bins[prevIdx].reduce((sum, r) => sum + r, 0) / bins[prevIdx].length;
                        const nextRadius = bins[nextIdx].reduce((sum, r) => sum + r, 0) / bins[nextIdx].length;
                        radius = (prevRadius + nextRadius) / 2;
                    } else {
                        continue; // Skip this angle
                    }
                }
                
                avgContour.push({
                    x: avgCentroid.x + radius * Math.cos(angle),
                    y: avgCentroid.y + radius * Math.sin(angle)
                });
            }
            
            // Calculate mean radius in units
            const radii = avgContour.map(p => {
                const dx = p.x - avgCentroid.x;
                const dy = p.y - avgCentroid.y;
                return Math.sqrt(dx * dx + dy * dy) / SCALE;
            });
            
            const meanRadius = radii.reduce((sum, r) => sum + r, 0) / radii.length;
            
            return {
                contour: avgContour,
                centroid: avgCentroid,
                meanRadius: meanRadius,
                n: shapes.length
            };
        }
        
        // ============================================
        // DRAWING FUNCTIONS - WITH HEAD CIRCLE
        // ============================================
        
        function drawCompositeVisualization(canvas, frequency, redShapes, blueShapes, redAvg, blueAvg) {
            const ctx = canvas.getContext('2d');
            
            // Clear with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            drawGrid(ctx);
            
            // Draw reference head circle (radius = 3 units)
            drawHeadCircle(ctx);
            
            // Draw individual shapes in gray (unfilled contours)
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.3;
            
            // Draw red individual shapes
            redShapes.forEach(shape => {
                if (shape.contour && shape.contour.length > 2) {
                    ctx.beginPath();
                    ctx.moveTo(shape.contour[0].x, shape.contour[0].y);
                    
                    for (let i = 1; i < shape.contour.length; i++) {
                        ctx.lineTo(shape.contour[i].x, shape.contour[i].y);
                    }
                    
                    ctx.closePath();
                    ctx.stroke();
                }
            });
            
            // Draw blue individual shapes
            blueShapes.forEach(shape => {
                if (shape.contour && shape.contour.length > 2) {
                    ctx.beginPath();
                    ctx.moveTo(shape.contour[0].x, shape.contour[0].y);
                    
                    for (let i = 1; i < shape.contour.length; i++) {
                        ctx.lineTo(shape.contour[i].x, shape.contour[i].y);
                    }
                    
                    ctx.closePath();
                    ctx.stroke();
                }
            });
            
            ctx.globalAlpha = 1.0;
            
            // Draw averaged red shape (solid line)
            if (redAvg && redAvg.contour && redAvg.contour.length > 0) {
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                
                ctx.beginPath();
                ctx.moveTo(redAvg.contour[0].x, redAvg.contour[0].y);
                
                for (let i = 1; i < redAvg.contour.length; i++) {
                    ctx.lineTo(redAvg.contour[i].x, redAvg.contour[i].y);
                }
                
                ctx.closePath();
                ctx.stroke();
            }
            
            // Draw averaged blue shape (dashed line)
            if (blueAvg && blueAvg.contour && blueAvg.contour.length > 0) {
                ctx.strokeStyle = '#0000FF';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                
                ctx.beginPath();
                ctx.moveTo(blueAvg.contour[0].x, blueAvg.contour[0].y);
                
                for (let i = 1; i < blueAvg.contour.length; i++) {
                    ctx.lineTo(blueAvg.contour[i].x, blueAvg.contour[i].y);
                }
                
                ctx.closePath();
                ctx.stroke();
                ctx.setLineDash([]);
            }
            
            // Add frequency label
            ctx.fillStyle = 'black';
            ctx.font = 'bold 32px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(frequency, canvas.width / 2, 40);
            
            // Add statistics
            const nTotal = redShapes.length + blueShapes.length;
            const meanRadius = redAvg ? redAvg.meanRadius.toFixed(2) : 
                              (blueAvg ? blueAvg.meanRadius.toFixed(2) : '0.00');
            
            ctx.font = '16px Arial';
            ctx.fillText(`N=${nTotal}, mean r=${meanRadius} (centroid avg)`, canvas.width / 2, canvas.height - 20);
        }
        
        function drawGrid(ctx) {
            const size = CANVAS_SIZE;
            const gridSize = size / (2 * GRID_RANGE);
            
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            
            // Grid lines
            for (let i = 0; i <= 2 * GRID_RANGE; i++) {
                const pos = i * gridSize;
                
                ctx.beginPath();
                ctx.moveTo(pos, 0);
                ctx.lineTo(pos, size);
                ctx.stroke();
                
                ctx.beginPath();
                ctx.moveTo(0, pos);
                ctx.lineTo(size, pos);
                ctx.stroke();
            }
            
            // Center axes
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 2;
            
            ctx.beginPath();
            ctx.moveTo(size / 2, 0);
            ctx.lineTo(size / 2, size);
            ctx.stroke();
            
            ctx.beginPath();
            ctx.moveTo(0, size / 2);
            ctx.lineTo(size, size / 2);
            ctx.stroke();
        }
        
        function drawHeadCircle(ctx) {
            // Draw the reference circle (human head) at center with radius 3 units
            ctx.strokeStyle = '#000000'; // Black
            ctx.lineWidth = 1;
            ctx.setLineDash([]);
            
            ctx.beginPath();
            ctx.arc(CENTER_X, CENTER_Y, HEAD_CIRCLE_RADIUS * SCALE, 0, 2 * Math.PI);
            ctx.stroke();
        }
        
        // ============================================
        // FILE PROCESSING
        // ============================================
        
        async function loadImagesFromZip(file) {
            const zip = await JSZip.loadAsync(file);
            const images = [];
            
            for (const [path, zipEntry] of Object.entries(zip.files)) {
                if (zipEntry.dir) continue;
                
                if (path.toLowerCase().endsWith('.png')) {
                    const blob = await zipEntry.async('blob');
                    images.push({
                        name: path.split('/').pop(),
                        blob: blob
                    });
                } else if (path.toLowerCase().endsWith('.zip')) {
                    // Handle nested ZIPs
                    const nestedBlob = await zipEntry.async('blob');
                    const nestedFile = new File([nestedBlob], path.split('/').pop());
                    const nestedImages = await loadImagesFromZip(nestedFile);
                    images.push(...nestedImages);
                }
            }
            
            return images;
        }
        
        async function processImage(imageFile) {
            return new Promise((resolve, reject) => {
                const img = new Image();
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    img.onload = async () => {
                        const canvas = document.createElement('canvas');
                        canvas.width = CANVAS_SIZE;
                        canvas.height = CANVAS_SIZE;
                        const ctx = canvas.getContext('2d');
                        
                        ctx.drawImage(img, 0, 0, CANVAS_SIZE, CANVAS_SIZE);
                        const imageData = ctx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
                        
                        const shapes = await extractShapesFromImage(imageData, imageFile.name);
                        
                        // Parse filename for metadata
                        const parsed = parseFilename(imageFile.name);
                        if (!parsed) {
                            console.warn(`Skipping file with invalid name format: ${imageFile.name}`);
                            resolve([]);
                            return;
                        }
                        
                        resolve(shapes.map(shape => ({
                            ...shape,
                            ...parsed,
                            filename: imageFile.name
                        })));
                    };
                    
                    img.onerror = () => reject(new Error(`Failed to load: ${imageFile.name}`));
                    img.src = e.target.result;
                };
                
                reader.onerror = () => reject(new Error(`Failed to read: ${imageFile.name}`));
                reader.readAsDataURL(imageFile.blob);
            });
        }
        
        function parseFilename(filename) {
            const parts = filename.replace('.png', '').split('_');
            if (parts.length < 2) return null;
            
            // Find frequency
            let frequency = null;
            for (const part of parts) {
                const match = part.match(/(\d+(?:\.\d+)?)hz/i);
                if (match) {
                    frequency = parseFloat(match[1]) + 'Hz';
                    break;
                }
            }
            
            if (!frequency) return null;
            
            const participant = parts[0];
            return { participant, frequency };
        }
        
        function updateProgress(percentage, message) {
            document.getElementById('progress-container').classList.remove('hidden');
            document.getElementById('progress-bar').style.width = `${percentage}%`;
            document.getElementById('progress-text').textContent = message;
            document.getElementById('progress-percentage').textContent = `${Math.round(percentage)}%`;
        }
        
        // ============================================
        // MAIN ANALYSIS FUNCTION
        // ============================================
        
        async function analyzeData(inputFiles) {
            try {
                updateProgress(0, 'Starting analysis...');
                
                // Extract all images
                let allImages = [];
                
                for (const file of inputFiles) {
                    if (file.name.toLowerCase().endsWith('.zip')) {
                        const images = await loadImagesFromZip(file);
                        allImages.push(...images);
                    } else if (file.name.toLowerCase().endsWith('.png')) {
                        allImages.push({ name: file.name, blob: file });
                    }
                }
                
                updateProgress(10, `Found ${allImages.length} images`);
                
                // Process all images
                const processedData = [];
                
                for (let i = 0; i < allImages.length; i++) {
                    try {
                        const result = await processImage(allImages[i]);
                        if (result && result.length > 0) {
                            processedData.push(...result);
                        }
                    } catch (error) {
                        console.warn(`Skipping ${allImages[i].name}:`, error);
                    }
                    
                    const progress = 10 + ((i + 1) / allImages.length * 60);
                    updateProgress(progress, `Processing image ${i + 1}/${allImages.length}`);
                }
                
                // Organize by frequency
                const organizedData = {};
                const frequencies = ['31Hz', '62.5Hz', '125Hz', '250Hz', '500Hz', 
                                   '1000Hz', '2000Hz', '4000Hz', '8000Hz', '12000Hz', '16000Hz'];
                
                frequencies.forEach(freq => {
                    organizedData[freq] = { red: [], blue: [] };
                });
                
                processedData.forEach(data => {
                    if (organizedData[data.frequency]) {
                        organizedData[data.frequency][data.phase].push(data);
                    }
                });
                
                updateProgress(75, 'Creating visualizations...');
                
                // Generate visualizations
                const vizGrid = document.getElementById('viz-grid');
                vizGrid.innerHTML = '';
                
                frequencies.forEach(freq => {
                    const redShapes = organizedData[freq].red;
                    const blueShapes = organizedData[freq].blue;
                    
                    if (redShapes.length === 0 && blueShapes.length === 0) return;
                    
                    // Calculate averages
                    const redAvg = redShapes.length > 0 ? calculateAverageShape(redShapes) : null;
                    const blueAvg = blueShapes.length > 0 ? calculateAverageShape(blueShapes) : null;
                    
                    // Create canvas
                    const canvas = document.createElement('canvas');
                    canvas.width = CANVAS_SIZE;
                    canvas.height = CANVAS_SIZE;
                    
                    drawCompositeVisualization(canvas, freq, redShapes, blueShapes, redAvg, blueAvg);
                    
                    // Create container
                    const container = document.createElement('div');
                    container.className = 'canvas-container p-4';
                    container.style.cursor = 'pointer';
                    
                    canvas.style.width = '100%';
                    canvas.style.height = 'auto';
                    
                    container.appendChild(canvas);
                    
                    // Add click to download
                    container.addEventListener('click', () => {
                        const link = document.createElement('a');
                        link.download = `composite_${freq}.png`;
                        link.href = canvas.toDataURL();
                        link.click();
                    });
                    
                    vizGrid.appendChild(container);
                });
                
                updateProgress(100, 'Analysis complete!');
                
                // Show results
                document.getElementById('visualization-container').classList.remove('hidden');
                
                setTimeout(() => {
                    document.getElementById('progress-container').classList.add('hidden');
                }, 2000);
                
            } catch (error) {
                console.error('Analysis error:', error);
                alert(`Error: ${error.message}`);
            }
        }
    </script>
</body>
</html>
