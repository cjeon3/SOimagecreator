<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sound Object Analyzer v9.0 - Enhanced Contours & Outlier Filtering</title>
    <meta name="version" content="9.0.0">
    <script src="https://cdn.tailwindcss.com"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
    <style>
        body {
            font-family: ui-sans-serif, system-ui, sans-serif;
            background-color: #f3f4f6;
        }
        
        .canvas-container {
            background: white;
            border-radius: 0.5rem;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            cursor: pointer;
        }
        
        .canvas-container:hover {
            transform: scale(1.02);
            transition: transform 0.2s;
        }
        
        .analysis-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(400px, 1fr));
            gap: 1.5rem;
        }
    </style>
</head>
<body>
    <div class="max-w-7xl mx-auto p-6">
        <!-- Header -->
        <div class="bg-gradient-to-r from-blue-600 to-purple-700 text-white p-6 rounded-xl shadow-xl mb-6">
            <h1 class="text-4xl font-bold mb-2">Sound Object Analyzer v9.0</h1>
            <p class="text-blue-100 text-lg">Radial Contours & Enhanced Outlier Filtering</p>
            <div class="mt-4 flex flex-wrap gap-2">
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">âœ“ Fixed Worm-Like Shapes</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">âœ“ MAD Outlier Filtering</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">âœ“ Gaussian Smoothing</span>
                <span class="bg-white/20 px-3 py-1 rounded-full text-sm">âœ“ Clean Closed Contours</span>
            </div>
        </div>
        
        <!-- Instructions -->
        <div class="bg-blue-50 p-6 rounded-xl mb-6 border-2 border-blue-200">
            <h2 class="text-xl font-bold text-blue-900 mb-3">Key Improvements in v9.0</h2>
            <ul class="space-y-2 text-gray-700">
                <li><strong>ðŸŽ¯ Radial Contour Extraction:</strong> Clean closed shapes, no more worm-like appendages</li>
                <li><strong>ðŸ“Š MAD-based Outlier Filtering:</strong> Removes shapes by area, radial profile, and centroid distance</li>
                <li><strong>âœ¨ Gaussian Smoothing:</strong> Smoother averaged contours for publication quality</li>
                <li><strong>ðŸ“ˆ Robust Statistics:</strong> Shows filtered/total counts (e.g., "15/20")</li>
            </ul>
        </div>
        
        <!-- File Upload -->
        <div class="bg-white p-6 rounded-xl shadow-lg mb-6">
            <h2 class="text-2xl font-bold text-gray-800 mb-4">Upload Participant Images</h2>
            <input 
                type="file" 
                id="image-upload" 
                accept="image/png,.zip,application/zip" 
                multiple
                class="block w-full text-sm text-gray-700 mb-4
                    file:mr-4 file:py-3 file:px-6
                    file:rounded-xl file:border-0
                    file:text-sm file:font-bold
                    file:bg-gradient-to-r file:from-blue-500 file:to-blue-600
                    file:text-white
                    hover:file:from-blue-600 hover:file:to-blue-700
                    cursor-pointer"
            />
            
            <div id="file-status" class="text-sm text-gray-600 mb-4"></div>
            
            <button 
                id="analyze-btn" 
                class="bg-gradient-to-r from-green-500 to-emerald-600 text-white font-bold py-3 px-6 rounded-xl hover:from-green-600 hover:to-emerald-700 transition-all shadow-lg disabled:opacity-50 disabled:cursor-not-allowed"
                disabled>
                ðŸ”¬ Analyze & Generate Visualizations
            </button>
        </div>
        
        <!-- Progress -->
        <div id="progress-container" class="hidden bg-white p-6 rounded-xl shadow-lg mb-6">
            <div class="flex justify-between text-sm text-gray-600 mb-2">
                <span id="progress-text">Processing...</span>
                <span id="progress-percentage">0%</span>
            </div>
            <div class="w-full bg-gray-200 rounded-full h-3 overflow-hidden">
                <div id="progress-bar" class="bg-gradient-to-r from-blue-500 to-green-500 h-full rounded-full transition-all duration-300" style="width: 0%"></div>
            </div>
        </div>
        
        <!-- Results -->
        <div id="visualization-container" class="hidden">
            <div class="bg-white p-6 rounded-xl shadow-lg mb-6">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">ðŸ“Š Composite Visualizations</h2>
                <p class="text-gray-600 mb-4">Click any image to download as PNG</p>
                <div id="visualizations" class="analysis-grid"></div>
            </div>
            
            <div class="bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-bold text-gray-800 mb-4">ðŸ“ˆ Summary Statistics</h2>
                <div id="summary" class="grid grid-cols-1 md:grid-cols-2 gap-4"></div>
            </div>
        </div>
    </div>
    
    <script>
        // ============================================
        // CONFIGURATION & CONSTANTS
        // ============================================
        const CANVAS_SIZE = 1000; // Drawing app canvas is 1000x1000
        const SCALE = 50; // 50 pixels per unit
        const GRID_RANGE = 10; // -10 to +10 units
        const CENTER_X = 500; // Center at (500, 500) in pixel coordinates
        const CENTER_Y = 500;
        const HEAD_RADIUS = 3; // Head circle radius in units
        
        let allProcessedData = new Map(); // Store all processed data by frequency
        
        // ============================================
        // FILE HANDLING
        // ============================================
        
        document.getElementById('image-upload').addEventListener('change', (event) => {
            const files = Array.from(event.target.files);
            const fileStatus = document.getElementById('file-status');
            const analyzeBtn = document.getElementById('analyze-btn');
            
            const zipCount = files.filter(f => f.name.toLowerCase().endsWith('.zip')).length;
            const pngCount = files.filter(f => f.name.toLowerCase().endsWith('.png')).length;
            
            fileStatus.textContent = `Selected: ${pngCount} PNG files, ${zipCount} ZIP archives`;
            analyzeBtn.disabled = files.length === 0;
        });
        
        document.getElementById('analyze-btn').addEventListener('click', analyzeImages);
        
        async function analyzeImages() {
            const fileInput = document.getElementById('image-upload');
            const files = Array.from(fileInput.files);
            
            if (files.length === 0) {
                alert('Please select images to analyze');
                return;
            }
            
            // Show progress
            document.getElementById('progress-container').classList.remove('hidden');
            updateProgress('Extracting files...', 0);
            
            // Extract all PNG files (from direct upload and from ZIPs)
            const pngFiles = await extractAllPNGs(files);
            
            if (pngFiles.length === 0) {
                alert('No PNG files found');
                document.getElementById('progress-container').classList.add('hidden');
                return;
            }
            
            // Process images
            await processImages(pngFiles);
            
            // Hide progress and show results
            document.getElementById('progress-container').classList.add('hidden');
            document.getElementById('visualization-container').classList.remove('hidden');
        }
        
        async function extractAllPNGs(files) {
            const pngFiles = [];
            
            for (const file of files) {
                if (file.name.toLowerCase().endsWith('.png')) {
                    pngFiles.push(file);
                } else if (file.name.toLowerCase().endsWith('.zip')) {
                    const zip = new JSZip();
                    const zipContent = await zip.loadAsync(file);
                    
                    for (const [filename, fileData] of Object.entries(zipContent.files)) {
                        if (filename.toLowerCase().endsWith('.png') && !fileData.dir) {
                            const blob = await fileData.async('blob');
                            pngFiles.push(new File([blob], filename, { type: 'image/png' }));
                        }
                    }
                }
            }
            
            return pngFiles;
        }
        
        // ============================================
        // IMAGE PROCESSING - RADIAL CONTOUR EXTRACTION
        // ============================================
        
        async function processImages(pngFiles) {
            allProcessedData.clear();
            const frequencyMap = new Map();
            
            // Group files by frequency
            pngFiles.forEach(file => {
                const match = file.name.match(/(\d+)hz/i);
                if (match) {
                    const freq = match[1];
                    if (!frequencyMap.has(freq)) {
                        frequencyMap.set(freq, []);
                    }
                    frequencyMap.get(freq).push(file);
                }
            });
            
            let processed = 0;
            const total = pngFiles.length;
            
            for (const [frequency, files] of frequencyMap) {
                updateProgress(`Processing ${frequency}Hz...`, (processed / total) * 100);
                
                const redShapes = [];
                const blueShapes = [];
                
                for (const file of files) {
                    const shapes = await extractShapesFromImage(file);
                    shapes.forEach(shape => {
                        if (shape.phase === 'red') {
                            redShapes.push(shape);
                        } else if (shape.phase === 'blue') {
                            blueShapes.push(shape);
                        }
                    });
                    processed++;
                    updateProgress(`Processing ${frequency}Hz...`, (processed / total) * 100);
                }
                
                // Filter outliers and calculate averages
                const filteredRed = filterOutliers(redShapes);
                const filteredBlue = filterOutliers(blueShapes);
                
                const redAvg = calculateAverageShape(filteredRed);
                const blueAvg = calculateAverageShape(filteredBlue);
                
                allProcessedData.set(frequency, {
                    redShapes: redShapes,
                    blueShapes: blueShapes,
                    filteredRed: filteredRed,
                    filteredBlue: filteredBlue,
                    redAvg: redAvg,
                    blueAvg: blueAvg
                });
                
                // Create visualization
                createVisualization(frequency, redShapes, blueShapes, redAvg, blueAvg);
            }
            
            // Update summary
            updateSummary();
        }
        
        async function extractShapesFromImage(file) {
            return new Promise((resolve) => {
                const img = new Image();
                const reader = new FileReader();
                
                reader.onload = (e) => {
                    img.onload = () => {
                        const shapes = processImageData(img);
                        resolve(shapes);
                    };
                    img.src = e.target.result;
                };
                
                reader.readAsDataURL(file);
            });
        }
        
        function processImageData(img) {
            const canvas = document.createElement('canvas');
            canvas.width = CANVAS_SIZE;
            canvas.height = CANVAS_SIZE;
            const ctx = canvas.getContext('2d');
            
            ctx.drawImage(img, 0, 0, CANVAS_SIZE, CANVAS_SIZE);
            const imageData = ctx.getImageData(0, 0, CANVAS_SIZE, CANVAS_SIZE);
            const data = imageData.data;
            
            // Extract colored pixels
            const redPixels = [];
            const bluePixels = [];
            
            for (let y = 0; y < CANVAS_SIZE; y++) {
                for (let x = 0; x < CANVAS_SIZE; x++) {
                    const idx = (y * CANVAS_SIZE + x) * 4;
                    const r = data[idx];
                    const g = data[idx + 1];
                    const b = data[idx + 2];
                    
                    // Blue detection (must be dominant)
                    if (b > r + 20 && b > g + 20) {
                        bluePixels.push({ x, y });
                    }
                    // Red detection (must be dominant)
                    else if (r > b + 20 && r > g + 20) {
                        redPixels.push({ x, y });
                    }
                }
            }
            
            const shapes = [];
            
            // Process red shape with radial extraction
            if (redPixels.length > 100) {
                const redContour = extractRadialContour(redPixels);
                if (redContour.length > 0) {
                    const redCentroid = calculateCentroid(redPixels);
                    shapes.push({
                        phase: 'red',
                        contour: redContour,
                        centroid: redCentroid,
                        area: calculateContourArea(redContour),
                        radialProfile: calculateRadialProfile(redContour, redCentroid)
                    });
                }
            }
            
            // Process blue shape with radial extraction
            if (bluePixels.length > 100) {
                const blueContour = extractRadialContour(bluePixels);
                if (blueContour.length > 0) {
                    const blueCentroid = calculateCentroid(bluePixels);
                    shapes.push({
                        phase: 'blue',
                        contour: blueContour,
                        centroid: blueCentroid,
                        area: calculateContourArea(blueContour),
                        radialProfile: calculateRadialProfile(blueContour, blueCentroid)
                    });
                }
            }
            
            return shapes;
        }
        
        // NEW: Radial contour extraction - no more worms!
        function extractRadialContour(pixels) {
            if (pixels.length === 0) return [];
            
            // Calculate centroid of all pixels
            const centroid = calculateCentroid(pixels);
            
            // Create a map of pixels for fast lookup
            const pixelMap = new Map();
            pixels.forEach(p => {
                const key = `${p.x},${p.y}`;
                pixelMap.set(key, p);
            });
            
            // Sample radially from centroid
            const contour = [];
            const numAngles = 360;
            
            for (let i = 0; i < numAngles; i++) {
                const angle = (i / numAngles) * 2 * Math.PI;
                const dx = Math.cos(angle);
                const dy = Math.sin(angle);
                
                // Find furthest pixel in this direction
                let maxDist = 0;
                let furthestPoint = null;
                
                // Search along ray from centroid
                for (let dist = 0; dist < 1000; dist += 1) {
                    const x = Math.round(centroid.x + dx * dist);
                    const y = Math.round(centroid.y + dy * dist);
                    const key = `${x},${y}`;
                    
                    if (pixelMap.has(key)) {
                        maxDist = dist;
                        furthestPoint = { x, y };
                    }
                }
                
                if (furthestPoint) {
                    contour.push(furthestPoint);
                }
            }
            
            // Smooth the contour
            return smoothContour(contour, 3);
        }
        
        function smoothContour(contour, windowSize) {
            if (contour.length < 3) return contour;
            
            const smoothed = [];
            const halfWindow = Math.floor(windowSize / 2);
            
            for (let i = 0; i < contour.length; i++) {
                let sumX = 0;
                let sumY = 0;
                let count = 0;
                
                for (let j = -halfWindow; j <= halfWindow; j++) {
                    const idx = (i + j + contour.length) % contour.length;
                    sumX += contour[idx].x;
                    sumY += contour[idx].y;
                    count++;
                }
                
                smoothed.push({
                    x: sumX / count,
                    y: sumY / count
                });
            }
            
            return smoothed;
        }
        
        function calculateCentroid(points) {
            if (points.length === 0) return { x: CENTER_X, y: CENTER_Y };
            
            const sumX = points.reduce((sum, p) => sum + p.x, 0);
            const sumY = points.reduce((sum, p) => sum + p.y, 0);
            
            return {
                x: sumX / points.length,
                y: sumY / points.length
            };
        }
        
        function calculateContourArea(contour) {
            if (contour.length < 3) return 0;
            
            // Shoelace formula
            let area = 0;
            for (let i = 0; i < contour.length; i++) {
                const j = (i + 1) % contour.length;
                area += contour[i].x * contour[j].y;
                area -= contour[j].x * contour[i].y;
            }
            
            return Math.abs(area / 2) / (SCALE * SCALE); // Convert to square units
        }
        
        function calculateRadialProfile(contour, centroid) {
            const radii = contour.map(p => {
                const dx = p.x - centroid.x;
                const dy = p.y - centroid.y;
                return Math.sqrt(dx * dx + dy * dy);
            });
            
            const mean = radii.reduce((sum, r) => sum + r, 0) / radii.length;
            const variance = radii.reduce((sum, r) => sum + Math.pow(r - mean, 2), 0) / radii.length;
            const stdDev = Math.sqrt(variance);
            
            return {
                mean: mean,
                stdDev: stdDev,
                coefficientOfVariation: stdDev / mean
            };
        }
        
        // ============================================
        // OUTLIER FILTERING WITH MAD
        // ============================================
        
        function filterOutliers(shapes) {
            if (shapes.length < 3) return shapes;
            
            console.log(`Starting outlier filtering with ${shapes.length} shapes`);
            
            // Step 1: Remove shapes with extreme areas
            const areas = shapes.map(s => s.area);
            const medianArea = median(areas);
            const areaMAD = medianAbsoluteDeviation(areas);
            
            let filtered = shapes.filter(shape => {
                const areaDiff = Math.abs(shape.area - medianArea);
                return areaDiff < 3 * areaMAD; // Keep within 3 MAD
            });
            
            console.log(`After area filtering: ${filtered.length} shapes`);
            
            // Step 2: Remove shapes with irregular radial profiles
            if (filtered.length > 0) {
                const cvs = filtered.map(s => s.radialProfile.coefficientOfVariation);
                const medianCV = median(cvs);
                const cvMAD = medianAbsoluteDeviation(cvs);
                
                filtered = filtered.filter(shape => {
                    const cvDiff = Math.abs(shape.radialProfile.coefficientOfVariation - medianCV);
                    return cvDiff < 3 * cvMAD; // Keep within 3 MAD
                });
                
                console.log(`After radial profile filtering: ${filtered.length} shapes`);
            }
            
            // Step 3: Remove shapes whose centroids are far from median
            if (filtered.length > 0) {
                const centroidXs = filtered.map(s => s.centroid.x);
                const centroidYs = filtered.map(s => s.centroid.y);
                const medianX = median(centroidXs);
                const medianY = median(centroidYs);
                
                const centroidDistances = filtered.map(s => {
                    const dx = s.centroid.x - medianX;
                    const dy = s.centroid.y - medianY;
                    return Math.sqrt(dx * dx + dy * dy);
                });
                
                const medianDist = median(centroidDistances);
                const distMAD = medianAbsoluteDeviation(centroidDistances);
                
                filtered = filtered.filter((shape, idx) => {
                    return centroidDistances[idx] < medianDist + 3 * distMAD;
                });
                
                console.log(`After centroid filtering: ${filtered.length} shapes`);
            }
            
            return filtered;
        }
        
        function median(values) {
            if (values.length === 0) return 0;
            const sorted = [...values].sort((a, b) => a - b);
            const mid = Math.floor(sorted.length / 2);
            return sorted.length % 2 === 0 ?
                (sorted[mid - 1] + sorted[mid]) / 2 :
                sorted[mid];
        }
        
        function medianAbsoluteDeviation(values) {
            if (values.length === 0) return 0;
            const med = median(values);
            const deviations = values.map(v => Math.abs(v - med));
            return median(deviations) * 1.4826; // Scale factor for normal distribution
        }
        
        // ============================================
        // AVERAGING WITH GAUSSIAN SMOOTHING
        // ============================================
        
        function calculateAverageShape(shapes) {
            if (shapes.length === 0) return null;
            
            // Calculate average centroid
            const avgCentroid = {
                x: shapes.reduce((sum, s) => sum + s.centroid.x, 0) / shapes.length,
                y: shapes.reduce((sum, s) => sum + s.centroid.y, 0) / shapes.length
            };
            
            // Normalize contours relative to average centroid and convert to polar
            const polarData = [];
            
            shapes.forEach(shape => {
                shape.contour.forEach(point => {
                    const dx = point.x - avgCentroid.x;
                    const dy = point.y - avgCentroid.y;
                    const angle = Math.atan2(dy, dx);
                    const radius = Math.sqrt(dx * dx + dy * dy);
                    polarData.push({ angle, radius });
                });
            });
            
            // Bin by angle and use median (more robust than mean)
            const numBins = 360;
            const bins = new Array(numBins).fill(null).map(() => []);
            
            polarData.forEach(point => {
                let binIndex = Math.floor(((point.angle + Math.PI) / (2 * Math.PI)) * numBins);
                binIndex = (binIndex + numBins) % numBins;
                bins[binIndex].push(point.radius);
            });
            
            // Create averaged contour using median for robustness
            const avgContour = [];
            for (let i = 0; i < numBins; i++) {
                const angle = (i / numBins) * 2 * Math.PI - Math.PI;
                
                let radius;
                if (bins[i].length > 0) {
                    radius = median(bins[i]); // Use median instead of mean for robustness
                } else {
                    // Interpolate from neighbors
                    let prevIdx = (i - 1 + numBins) % numBins;
                    let nextIdx = (i + 1) % numBins;
                    
                    while (bins[prevIdx].length === 0 && prevIdx !== i) {
                        prevIdx = (prevIdx - 1 + numBins) % numBins;
                    }
                    while (bins[nextIdx].length === 0 && nextIdx !== i) {
                        nextIdx = (nextIdx + 1) % numBins;
                    }
                    
                    if (bins[prevIdx].length > 0 && bins[nextIdx].length > 0) {
                        const prevRadius = median(bins[prevIdx]);
                        const nextRadius = median(bins[nextIdx]);
                        radius = (prevRadius + nextRadius) / 2;
                    } else {
                        continue;
                    }
                }
                
                avgContour.push({
                    x: avgCentroid.x + radius * Math.cos(angle),
                    y: avgCentroid.y + radius * Math.sin(angle)
                });
            }
            
            // Apply Gaussian smoothing to the averaged contour
            const smoothedContour = gaussianSmooth(avgContour, 2.0);
            
            // Calculate mean radius in units
            const radii = smoothedContour.map(p => {
                const dx = p.x - avgCentroid.x;
                const dy = p.y - avgCentroid.y;
                return Math.sqrt(dx * dx + dy * dy) / SCALE;
            });
            
            const meanRadius = radii.reduce((sum, r) => sum + r, 0) / radii.length;
            
            return {
                contour: smoothedContour,
                centroid: avgCentroid,
                meanRadius: meanRadius,
                n: shapes.length,
                nTotal: shapes.length // Will be updated by caller with original count
            };
        }
        
        function gaussianSmooth(contour, sigma) {
            if (contour.length < 3) return contour;
            
            const smoothed = [];
            const kernelSize = Math.ceil(sigma * 3);
            
            // Create Gaussian kernel
            const kernel = [];
            let kernelSum = 0;
            for (let i = -kernelSize; i <= kernelSize; i++) {
                const weight = Math.exp(-(i * i) / (2 * sigma * sigma));
                kernel.push(weight);
                kernelSum += weight;
            }
            
            // Normalize kernel
            for (let i = 0; i < kernel.length; i++) {
                kernel[i] /= kernelSum;
            }
            
            // Apply convolution
            for (let i = 0; i < contour.length; i++) {
                let sumX = 0;
                let sumY = 0;
                
                for (let j = -kernelSize; j <= kernelSize; j++) {
                    const idx = (i + j + contour.length) % contour.length;
                    const weight = kernel[j + kernelSize];
                    sumX += contour[idx].x * weight;
                    sumY += contour[idx].y * weight;
                }
                
                smoothed.push({ x: sumX, y: sumY });
            }
            
            return smoothed;
        }
        
        // ============================================
        // DRAWING FUNCTIONS - WITH HEAD CIRCLE
        // ============================================
        
        function createVisualization(frequency, redShapes, blueShapes, redAvg, blueAvg) {
            const container = document.getElementById('visualizations');
            
            // Create canvas
            const canvas = document.createElement('canvas');
            canvas.width = CANVAS_SIZE;
            canvas.height = CANVAS_SIZE;
            canvas.className = 'canvas-container';
            
            // Draw composite
            drawCompositeVisualization(canvas, frequency, redShapes, blueShapes, redAvg, blueAvg);
            
            // Create wrapper with frequency label
            const wrapper = document.createElement('div');
            wrapper.className = 'text-center';
            
            const label = document.createElement('p');
            label.className = 'text-lg font-semibold text-gray-700 mb-2';
            label.textContent = `${frequency} Hz`;
            
            wrapper.appendChild(label);
            wrapper.appendChild(canvas);
            
            // Add download functionality
            canvas.addEventListener('click', () => {
                const link = document.createElement('a');
                link.download = `composite_${frequency}Hz.png`;
                link.href = canvas.toDataURL();
                link.click();
            });
            
            container.appendChild(wrapper);
        }
        
        function drawCompositeVisualization(canvas, frequency, redShapes, blueShapes, redAvg, blueAvg) {
            const ctx = canvas.getContext('2d');
            
            // Clear with white background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid
            drawGrid(ctx);
            
            // Draw reference head circle (radius = 3 units)
            drawHeadCircle(ctx);
            
            // Draw individual shapes in gray (unfilled contours)
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 1;
            ctx.globalAlpha = 0.3;
            
            // Get filtered shapes from the stored data
            const data = allProcessedData.get(frequency);
            const filteredRed = data ? data.filteredRed : redShapes;
            const filteredBlue = data ? data.filteredBlue : blueShapes;
            
            // Draw filtered red individual shapes
            filteredRed.forEach(shape => {
                if (shape.contour && shape.contour.length > 2) {
                    ctx.beginPath();
                    ctx.moveTo(shape.contour[0].x, shape.contour[0].y);
                    
                    for (let i = 1; i < shape.contour.length; i++) {
                        ctx.lineTo(shape.contour[i].x, shape.contour[i].y);
                    }
                    
                    ctx.closePath();
                    ctx.stroke();
                }
            });
            
            // Draw filtered blue individual shapes
            filteredBlue.forEach(shape => {
                if (shape.contour && shape.contour.length > 2) {
                    ctx.beginPath();
                    ctx.moveTo(shape.contour[0].x, shape.contour[0].y);
                    
                    for (let i = 1; i < shape.contour.length; i++) {
                        ctx.lineTo(shape.contour[i].x, shape.contour[i].y);
                    }
                    
                    ctx.closePath();
                    ctx.stroke();
                }
            });
            
            ctx.globalAlpha = 1.0;
            
            // Draw averaged red shape (solid line)
            if (redAvg && redAvg.contour && redAvg.contour.length > 0) {
                ctx.strokeStyle = '#FF0000';
                ctx.lineWidth = 3;
                ctx.setLineDash([]);
                
                ctx.beginPath();
                ctx.moveTo(redAvg.contour[0].x, redAvg.contour[0].y);
                
                for (let i = 1; i < redAvg.contour.length; i++) {
                    ctx.lineTo(redAvg.contour[i].x, redAvg.contour[i].y);
                }
                
                ctx.closePath();
                ctx.stroke();
            }
            
            // Draw averaged blue shape (dashed line)
            if (blueAvg && blueAvg.contour && blueAvg.contour.length > 0) {
                ctx.strokeStyle = '#0000FF';
                ctx.lineWidth = 3;
                ctx.setLineDash([10, 5]);
                
                ctx.beginPath();
                ctx.moveTo(blueAvg.contour[0].x, blueAvg.contour[0].y);
                
                for (let i = 1; i < blueAvg.contour.length; i++) {
                    ctx.lineTo(blueAvg.contour[i].x, blueAvg.contour[i].y);
                }
                
                ctx.closePath();
                ctx.stroke();
            }
            
            ctx.setLineDash([]);
            
            // Add frequency label and statistics
            ctx.fillStyle = '#333333';
            ctx.font = 'bold 24px sans-serif';
            ctx.fillText(`${frequency} Hz`, 50, 50);
            
            ctx.font = '16px sans-serif';
            let statsY = 80;
            
            if (redAvg) {
                // Update with total count
                redAvg.nTotal = redShapes.length;
                ctx.fillStyle = '#FF0000';
                ctx.fillText(
                    `In-phase: N=${redAvg.n}/${redAvg.nTotal}, Mean R=${redAvg.meanRadius.toFixed(2)} units`,
                    50,
                    statsY
                );
                statsY += 25;
            }
            
            if (blueAvg) {
                // Update with total count
                blueAvg.nTotal = blueShapes.length;
                ctx.fillStyle = '#0000FF';
                ctx.fillText(
                    `Out-of-phase: N=${blueAvg.n}/${blueAvg.nTotal}, Mean R=${blueAvg.meanRadius.toFixed(2)} units`,
                    50,
                    statsY
                );
            }
        }
        
        function drawGrid(ctx) {
            ctx.strokeStyle = '#e0e0e0';
            ctx.lineWidth = 1;
            
            // Vertical lines
            for (let i = 0; i <= 20; i++) {
                const x = i * SCALE;
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, CANVAS_SIZE);
                ctx.stroke();
            }
            
            // Horizontal lines
            for (let i = 0; i <= 20; i++) {
                const y = i * SCALE;
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(CANVAS_SIZE, y);
                ctx.stroke();
            }
            
            // Draw axes (thicker lines at center)
            ctx.strokeStyle = '#999999';
            ctx.lineWidth = 2;
            
            // X-axis
            ctx.beginPath();
            ctx.moveTo(0, CENTER_Y);
            ctx.lineTo(CANVAS_SIZE, CENTER_Y);
            ctx.stroke();
            
            // Y-axis
            ctx.beginPath();
            ctx.moveTo(CENTER_X, 0);
            ctx.lineTo(CENTER_X, CANVAS_SIZE);
            ctx.stroke();
        }
        
        function drawHeadCircle(ctx) {
            // Draw reference head circle at radius 3 units
            ctx.strokeStyle = '#000000';
            ctx.lineWidth = 2;
            ctx.setLineDash([]);
            
            ctx.beginPath();
            ctx.arc(CENTER_X, CENTER_Y, HEAD_RADIUS * SCALE, 0, 2 * Math.PI);
            ctx.stroke();
        }
        
        // ============================================
        // UI UPDATES
        // ============================================
        
        function updateProgress(text, percentage) {
            document.getElementById('progress-text').textContent = text;
            document.getElementById('progress-percentage').textContent = `${Math.round(percentage)}%`;
            document.getElementById('progress-bar').style.width = `${percentage}%`;
        }
        
        function updateSummary() {
            const summaryContainer = document.getElementById('summary');
            summaryContainer.innerHTML = '';
            
            let totalRed = 0;
            let totalBlue = 0;
            let filteredRed = 0;
            let filteredBlue = 0;
            
            allProcessedData.forEach((data, freq) => {
                totalRed += data.redShapes.length;
                totalBlue += data.blueShapes.length;
                filteredRed += data.filteredRed.length;
                filteredBlue += data.filteredBlue.length;
            });
            
            const stats = [
                { label: 'Total Frequencies Analyzed', value: allProcessedData.size },
                { label: 'Total Red Shapes', value: `${filteredRed}/${totalRed} (${Math.round(filteredRed/totalRed*100)}% retained)` },
                { label: 'Total Blue Shapes', value: `${filteredBlue}/${totalBlue} (${Math.round(filteredBlue/totalBlue*100)}% retained)` },
                { label: 'Outlier Filtering', value: 'MAD-based (3Ïƒ threshold)' }
            ];
            
            stats.forEach(stat => {
                const div = document.createElement('div');
                div.className = 'bg-gray-50 p-4 rounded-lg';
                div.innerHTML = `
                    <p class="text-sm text-gray-600">${stat.label}</p>
                    <p class="text-xl font-bold text-gray-800">${stat.value}</p>
                `;
                summaryContainer.appendChild(div);
            });
        }
        
        // Initialize
        console.log('Sound Object Analyzer v9.0 loaded');
        console.log('Improvements:');
        console.log('  âœ“ Radial contour extraction (no more worms!)');
        console.log('  âœ“ Enhanced outlier filtering (area, radial profile, centroid)');
        console.log('  âœ“ Gaussian smoothing for averaged contours');
        console.log('  âœ“ Median-based averaging (more robust)');
    </script>
</body>
</html>
